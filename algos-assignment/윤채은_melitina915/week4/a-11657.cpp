// 벨만-포드 (bellman-ford-moore)
// - 최단 거리를 구하는 알고리즘
// 기능
// - 특정 출발 노드에서 다른 모든 노드까지의 최단 경로 탐색
// 특징
// - 음수 가중치 에지가 있어도 수행할 수 있음
// - 전체 그래프에서 음수 사이클의 존재 여부를 판단할 수 있음
// 시간 복잡도 (노드 수 : V, 에지 수 : E)
// - O(VE)

// 벨만-포드의 핵심 이론
// - 벨만-포드 알고리즘은 다음 3가지 단계의 원리로 동작합니다.
// 1. 에지 리스트로 그래프를 구현하고 최단 경로 배열 초기화하기
// - 벨만-포드 알고리즘은 에지를 중심으로 동작하므로
// 그래프를 에지 리스트로 구현합니다.
// - 또한 최단 경로 배열을 출발 노드는 0, 나머지 노드는 무한대로 초기화합니다.
// 2. 모든 에지를 확인해 정답 배열 업데이트하기
// - 최단 거리 배열에서 업데이트 반복 횟수는 (노드 개수 - 1)입니다.
// - 노드 개수가 N이고, 음수 사이클이 없을 때
// 특정 두 노드의 최단 거리를 구성할 수 있는 에지의 최대 개수는 N - 1이기 때문입니다.
// - 모든 에지 E = (s, e, w)에서 다음 조건을 만족하면 업데이트를 실행합니다.
// - 업데이트 반복 횟수가 K번이라면 해당 시점에 정답 배열의 값은
// 시작접에서 K개의 에지를 사용했을 때 각 노드에 대한 최단 거리이다.
// * 업데이트 조건과 방법
// - D[s] != (무한대)이며
// D[e] > D[s] + w일 때 D[e] = D[s] + w로 배열의 값을 업데이트한다.
// - 음수 사이클이 없을 때 최대 에지 개수가 나오려면
// 사향 트리 형태에서 양 도착 노드를 선택해야 한다.
// - 에지의 출발 노드를 s, 종료 노드를 e, 에지의 가중치를 w로 가정했다.
// - 음수 사이클이 없을 때 N - 1번 에지 사용 횟수를 반복하면
// 출발 노드와 모든 노드 간의 최단 거리를 알려 주는 정답 배열이 완성된다.
// - 이렇게 완성 후 마지막으로 이 그래프에 음수 사이클이 존재하는지 확인해야 한다.
// 3. 음수 사이클 유무 확인하기
// - 음수 사이클 유무를 확인하기 위해 모든 에지를 한 번씩 다시 사용해
// 업데이트되는 노드가 발생하는지 확인합니다.
// - 만약 업데이트되는 노드가 있다면 음수 사이클이 있다는 뜻이 되고,
// 2단계에서 도출한 정답 배열이 무의미하고
// 최단 거리를 찾을 수 없는 그래프라는 뜻이 됩니다.
// - 음수 사이클이 존재하면 이 사이클을 무한하게 돌수록
// 가중치가 계속 감소하므로 최단 거리를 구할 수 없습니다.
// - 실제 알고리즘 코딩 테스트에서는
// 벨만-포드 알고리즘을 사용해 최단 거리를 구하는 문제보다
// 음수 사이클을 판별하는 문제가 더 빈번하게 출제됩니다.
// - 따라서 마지막에 한 번 더 모든 에지를 사용해
// 업데이트되는 노드가 존재하는지 확인해야 합니다.



// 문제 분석하기
// - 시작점 및 다른 노드와 관련된 최단 거리를 구하는 문제지만,
// 특이한 점은 에지에 해당하는 이동하는 시간이 양수가 아닌 0 또는 음수가 가능하다는 것이다.
// - 이렇게 시작점에서 다른 노드와 관련된 최단 거리를 구하는데,
// 에지가 음수가 가능할 때는 벨만-포드 알고리즘을 사용하면 된다.
// 손으로 풀어 보기
// 1. 에지 리스트에 에지 데이터를 저장한 후 거리 배열을 다음과 같이 초기화한다.
// 최초 시작점에 해당하는 거리 배열값은 0으로 초기화한다.
// 2. 다음 순서에 따라 벨만-포드 알고리즘을 수행한다.
// 벨만-포드 알고리즘 수행 과정
// 1) 모든 에지와 관련된 정보를 가져온 후 다음 조건에 따라 거리 배열의 값을 업데이트한다.
// - 출발 노드가 방문한 적이 없는 노드(출발 노드 거리 == INF)일 때
// 값을 업데이트하지 않는다.
// - 출발 노드의 거리 배열값 + 에지 가중치 < 종료 노드의 거리 배열값일 때
// 종료 노드의 거리 배열값을 업데이트한다.
// 2) '노드 개수 - 1'번만큼 1)을 반복한다.
// 3) 음수 사이클 유무를 알기 위해 모든 에지에 관해 다시 한번 1)을 수행한다.
// 이때 한 번이라도 값이 업데이트되면 음수 사이클이 존재한다고 판단한다.
// * 실제 코드 디버그값과 이론에서의 값이 달라 혼동될 수 있지만,
// 알고리즘에 영향을 미치진 않는다.
// 3. 음수 사이클이 존재하면 -1, 존재하지 않으면 거리 배열의 값을 출력한다.
// 단, 거리 배열의 값이 INF일 경우에는 -1을 출력한다.

// 슈도코드 작성하기
/*
edge(에지 정보 표현을 위한 tuple 변수)
edges(에지 정보 표현을 위한 에지 리스트)
mdistance(최단 거리 저장)
V(노드 개수)
E(에지 개수)
최단 거리 배열은 충분히 큰 수로 초기화

for (에지 개수) {
	에지 리스트 배열에 에지 정보를 저장
}

// 벨만-포드 알고리즘 수행하기
거리 배열에 출발 노드 0으로 초기화

for (노드 개수 - 1만큼 반복) {
	for (에지 개수만큼 반복) {
		현재 에지 데이터 가져오기
			if (출발 노드가 무한대가 아니라 종료 노드값 < 출발 노드값 + 에지 가중치) {
				업데이트 수행->종료 노드값 = 출발 노드값 + 에지 가중치
			}
	}
	// 음수 사이클 존재 여부 확인하기
	for (에지 개수만큼 반복) {
		현재 에지 데이터 가져오기
			if (출발 노드가 무한대가 아니고 종료 노드값 < 출발 노드값 + 에지 가중치) {
				업데이트 가능->음수 사이클 존재
			}
	}
}
음수 사이클 미존재 -> 거리 배열 출력(단, 거리 배열의 값이 무한대일 때 -1 출력)
음수 사이클 존재 -> -1 출력
*/
// 코드 구현하기
#include <iostream>
#include <vector>
#include <limits.h>
#include <tuple>
using namespace std;


// edge(에지 정보 표현을 위한 tuple 변수)
typedef tuple<int, int, int> edge;
// V(노드 개수)
// E(에지 개수)
// N개의 도시가 있다.
// 그리고 한 도시에서 출발하여 다른 도시에 도착하는 버스가 M개 있다.
static int N, M;
// mdistance(최단 거리 저장)
static vector<long> mdistance;
// edges(에지 정보 표현을 위한 에지 리스트)
static vector <edge> edges;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // 첫째 줄에 도시의 개수 N (1 ≤ N ≤ 500),
    // 버스 노선의 개수 M (1 ≤ M ≤ 6,000)이 주어진다.
    cin >> N >> M;

    mdistance.resize(N + 1);
    // 최단거리 배열 초기화
    // 최단 거리 배열은 충분히 큰 수로 초기화
    std::fill(mdistance.begin(), mdistance.end(), LONG_MAX);

    // 간선 리스트에 데이터 저장하기
    /*
    for (에지 개수) {
	    에지 리스트 배열에 에지 정보를 저장
    }   
    */
    // 둘째 줄부터 M개의 줄에는 버스 노선의 정보 A, B, C
    // (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)가 주어진다. 
    for (int i = 0; i < M; i++) { 
        // 각 버스는 A, B, C로 나타낼 수 있는데,
        // A는 시작도시, B는 도착도시,
        // C는 버스를 타고 이동하는데 걸리는 시간이다. 
        int start, end, time;

        cin >> start >> end >> time;

        edges.push_back(make_tuple(start, end, time));
    }

    // 시간 C가 양수가 아닌 경우가 있다.
    // C = 0인 경우는 순간 이동을 하는 경우,
    // C < 0인 경우는 타임머신으로 시간을 되돌아가는 경우이다.
    // 1번 도시에서 출발해서 나머지 도시로 가는
    // 가장 빠른 시간을 구하는 프로그램을 작성하시오.
    // 벨만포드 알고리즘 수행
    // 거리 배열에 출발 노드 0으로 초기화
    mdistance[1] = 0;

    //N보다 하나 적은 수만큼 반복
    //for (노드 개수 - 1만큼 반복) {
    for (int i = 1; i < N; i++) {  
        // for (에지 개수만큼 반복) {
        for (int j = 0; j < M; j++) {
            // 현재 에지 데이터 가져오기
            edge medge = edges[j];
            
            int start = get<0>(medge);
            int end = get<1>(medge);
            int time = get<2>(medge);

            // 더 작은 최단거리 가 있는 경우 갱신
            // if (출발 노드가 무한대가 아니라 종료 노드값 < 출발 노드값 + 에지 가중치) {
            if (mdistance[start] != LONG_MAX && mdistance[end] > mdistance[start] + time) {
                // 업데이트 수행->종료 노드값 = 출발 노드값 + 에지 가중치
                mdistance[end] = mdistance[start] + time;
            }
        }
    }

    bool mCycle = false;
    
    // 음수 cycle 확인
    // 음수 사이클 존재 여부 확인하기
    // for (에지 개수만큼 반복) {
    for (int i = 0; i < M; i++) {
        // 현재 에지 데이터 가져오기
        edge medge = edges[i];

        int start = get<0>(medge);
        int end = get<1>(medge);
        int time = get<2>(medge);
        
        // if (출발 노드가 무한대가 아니고 종료 노드값 < 출발 노드값 + 에지 가중치) {
        if (mdistance[start] != LONG_MAX && mdistance[end] > mdistance[start] + time) {
            // 업데이트 가능->음수 사이클 존재
            mCycle = true;
        }
    }
    // 음의 cycle이 없는 경우
    // 음수 사이클 미존재->거리 배열 출력(단, 거리 배열의 값이 무한대일 때 - 1 출력)
    // 그렇지 않다면 N-1개 줄에 걸쳐 각 줄에 1번 도시에서 출발해
    // 2번 도시, 3번 도시, ..., N번 도시로 가는
    // 가장 빠른 시간을 순서대로 출력한다.
    if (!mCycle) { 
        for (int i = 2; i <= N; i++) {
            // 만약 해당 도시로 가는 경로가 없다면 대신 -1을 출력한다.
            if (mdistance[i] == LONG_MAX)
                cout << -1 << "\n";
            else
                cout << mdistance[i] << "\n";
        }
    }
    // 음의 cycle이 있는 경우
    // 음수 사이클 존재 -> - 1 출력
    // 만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서
    // 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다.
    else { 
        cout << -1 << "\n";
    }
}