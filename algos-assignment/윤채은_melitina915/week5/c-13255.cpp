#include <iostream>
using namespace std;
using ll = long long;
using pii = pair <int, int>;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    // N개의 동전이 탁자 위에 놓여져 있다.
    // 동전은 모두 앞면이 위를 향하고 있다.
    int N, K;
    
    // 첫째 줄에 동전의 개수 N (1 ≤ N ≤ 1,000)이 주어진다. 
    // 둘째 줄에는 K (1 ≤ K ≤ 50)이 주어진다.
    cin >> N >> K;

    double pr = N;

    // 셋째 줄에는 A[i] (1 ≤ A[i] ≤ N)가 주어진다.
    // K개의 정수 A[i]가 주어진다.
    // 가장 처음에 A[1]개의 동전을 랜덤하게 골라서 뒤집는다.
    // 그 다음에는 A[2]개의 동전을 랜덤하게 골라서 뒤집는다.
    // 이 과정을 계속해서 반복하고,
    // 마지막에는 A[K]개의 동전을 랜덤하게 골라서 뒤집는다.
    while (K--) {
        int a;

        cin >> a;
        
        double temp = 0.0;
        
        // 모든 과정을 완료했을 때,
        // 앞면이 위를 향하는 동전 개수의 기댓값을 구하는 프로그램을 작성하시오.
        //(앞면 기댓값 * 안 뒤집을 확률) + (뒷면 기댓값 * 뒤집을 확률)
        temp += pr * (1 - (double)a / N);
        temp += (N - pr) * ((double)a / N);
        
        pr = temp;
    }

    // 정답과의 절대/상대 오차는 10^(-9)까지 허용한다.
    cout.fixed;
    cout.precision(11);

    // 모든 과정을 완료한 후에 앞면이 위를 향하는 동전 개수의 기댓값을 출력한다.
    cout << pr;
}

/*
기댓값의 선형성
: 제비뽑기에서 먼저 뽑든지 나중에 뽑든지가 확률적으로는 영향을 안 미치듯이
전체 N개에서 a개를 랜덤하게 수행한다고 했을 때
각각의 개체가 수행될 확률은 모두 a/N으로 동일함

-> 따라서 한 과정을 거칠때마다 이전 단계에서 가지고 있던 기댓값을 바탕으로
(앞면 기댓값 * 안 뒤집을 확률) + (뒷면 기댓값 * 뒤집을 확률)
이런 방식으로 업데이트해나가면 된다.
*/