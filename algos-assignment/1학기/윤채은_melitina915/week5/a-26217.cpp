// 다이나믹 프로그래밍 (동적 계획법, Dynamic Programming, DP)
// - 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려
// 주어진 문제를 해결하는 알고리즘
// - 문제를 해결하기 위한 점화식을 찾아낸 후 점화식의 항을
// 밑에서부터 차례로 구해나가서 답을 알아내는 형태의 알고리즘
// - 중간 결과를 저장해서 이용하는지 그렇지 않은지에 따라
// 극적인 시간복잡도의 차이가 발생한다

// DP를 푸는 과정
// 1. 테이블 정의하기
// 2. 점화식 찾기
// 3. 초기값 정하기
// - DP를 풀기 위해서는 먼저 테이블을 정의해야 하고 점화식을 찾은 후에
// 초기 값을 정해야 한다.
// - DP는 작정하고 어렵게 하고자 한다면 한도 끝도 없이 어려워지지만
// 코딩테스트에 나올 수준의 DP 문제는 일단 점화식만 찾고나면
// 그 뒤는 초기 값을 채워넣은 후에 반복문을 돌면서 배열을 채우면 끝이어서
// 구현이 굉장히 쉽다
// - 하지만 다양한 DP 문제를 풀어봤거나
// 뛰어난 수학적 직관력을 가지고 있지 않은 이상
// 문제에서 점화식을 이끌어내는 과정이 그렇게 쉽지 않고,
// 무엇보다도 초보 단계에서는 주어진 문제가 DP로 푸는 문제라는 것 자체를
// 알아차리지 못할 수도 있다.
// - 때문에 쉬운 문제를 많이 다뤄서 테이블을 잡고 식을 찾는 연습이 필요하다
// - 적당한 난이도의 DP 문제들을 많이 풀고 식을 머리속으로 고민하면서
// 많은 유형을 학습하고 숙달하는 것이 중요하다.
// - 그래야 코딩테스트에서 DP 문제가 나왔을 때 빠르게 풀 수 있다.



// 동적 계획법 (dynammic programming)
// - 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써
// 최종적으로 복잡한 문제의 답을 구하는 방법을 뜻한다.

// 동적 계획법의 핵심 이론
// 동적 계획법의 원리와 구현 방식
// 1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
// 2. 작은 문제들이 반복돼 나타나고 사용되며
// 이 작은 문제들의 결과값은 항상 같아야 한다.
// 3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며
// 추후 재사용할 때는 이 DP 테이블을 이용한다.
// 4. 동적 계획법은 톱-다운 방식(top-down)과
// 바텀-업(bottom-up) 방식으로 구현할 수 있다.

// 동적 계획법의 가장 대표적인 문제 피보나치 수열
// 피보나치 수열 공식 : D[N] = D[N - 1] + D[N - 2]
// N번째 수열 = N - 1번째 수열 + N - 2번째 수열
// 1. 동적 계획법으로 풀 수 있는지 확인하기
// - 6번째 피보나치 수열은
// 5번째 피보나치 수열과 4번째 피보나치 수열의 합이다.
// - 즉, 6번째 피보나치 수열을 구하는 문제는
// 5번째 피보나치 수열과 4번째 피보나치 수열을 구하는 작은 문제로 나눌 수 있고,
// 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있다.
// 2. 점화식 세우기
// - 점화식을 세울 때는 논리적으로 전체 문제를 나누고,
// 전체 문제와 부분 문제 간의 인과 관계를 파악하는 훈련이 필요하다.
// - 이 부분은 다양한 실전 문제를 풀면서 자연스럽게 훈련된다.
// - 이 예제는 피보나치 수열의 공식 자체가 점화식이므로
// 공식을 점화식으로 사용한다.
// - 즉, 피보나치 수열의 점화식은 D[i] = D[i - 1] + D[i - 2]가 된다.
// 3. 메모이제이션 원리 이해하기
// - 메모이제이션은 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장해 놓고
// 다음에 같은 문제가 나왔을 때 재계산하지 않고
// DP 테이블의 값을 이용하는 것을 말한다.
// - 예를 들어 2번째와 3번째 피보나치 수열은
// 맨 왼쪽 탐색 부분에서 최초로 값이 구해지고, 이때 DP테이블에 값이 저장된다.
// - 이에 따라 나중에 2번째와 3번째 피보나치 수열의 값이 필요할 때
// 재연산을 이용해 구하지 않고, DP 테이블에서 바로 값을 추출한다.
// - 이러한 방식을 사용하면 불필요한 연산과 탐색이 줄어들어
// 시간 복잡도 측면에서 많은 이점을 가질 수 있다.
// 4. 톱-다운 구현 방식 이해하기
// - 톱-다운 구현 방식은 말 그대로 위에서부터 문제를 파악해 내려오는 방식으로,
// 주로 재귀 함수 형태로 코드를 구현한다.
// - 코드의 가독성이 좋고, 이해하기가 편하다는 장점이 있다.
// 5. 바텀-업 구현 방식 이해하기
// - 가장 작은 부분 문제부터 문제를 해결하면서
// 점점 큰 문제로 확장해 나가는 방식이다.
// - 주로 반복문의 형태로 구현한다.
// - 두 방식 중 좀 더 안전한 방식은 바텀-업이다.
// - 톱-다운 방식은 재귀 함수의 형태로 구현돼 있기 때문에
// 재귀의 깊이가 매우 깊어질 경우 런타임 에러가 발생할 수 있다.
// - 하지만 실제 코딩 테스트에서 이 부분까지 고려해야 하는 문제는 잘 나오지 않는다.
// - 오히려 자신이 구현한 함수에 버그가 있을 확률이 더 높을 것이다.
// - 이 부분을 제외하면 두 방식의 차이점은 거의 없다고 할 수 있다.
// - 자신에게 좀 더 편한 방식이나 문제에 따라 두 방식 중 1개를 선택해 사용하면 된다.
// - 동적 계획법은 매우 중요하므로 가장 많은 문제를 다뤄야 한다.

#include <iostream>
#include <algorithm>
using namespace std;

double harmonic(double n) {
    double sum = 0;
    
    // N개의 꽃이 모두 피어나기 위한 기댓값은
    // 베르누이 시행에서의 성공 횟수의 기댓값을 묻는 문제이다.
    // E = N(1+1/2+1/3+1/4+...+1/N) 으로 조화수열의 형태로 나온다.
    for (double i = 1; i < n + 1; i++) {
        sum += 1 / i;
    }

    return sum;
}

int main(void) {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    // 마법의 씨앗에서 피어날 수 있는 꽃들의 종류는 N가지이며,
    // 각 종류의 꽃들이 피어날 확률은 동일하다.
    // 씨앗에서 꽃이 피어날 확률은 다른 씨앗에 영향을 받지 않는다.
    // (1 <= N <= 1000)
    double n, ans;

    // 첫 줄에 꽃들의 종류의 수를 의미하는 정수 N이 주어진다.
    cin >> n;

    // 화관을 만들기 위해서는 모든 종류의 꽃들이 최소 한 송이씩 필요하다. 
    // 화관이 만들어질 때까지 씨앗에서 꽃을 한 송이씩 피운다면,
    // 필요한 씨앗 개수의 기댓값은 얼마일까?
    ans = n * harmonic(n);

    // 화관을 만들기 위해서 필요한 씨앗 개수의 기댓값을 출력한다. 
    // 정답과의 절대 오차/상대 오차 중 하나가 10^(-4)이하라면
    // 정답으로 인정된다.
    cout << ans;

    return 0;
}